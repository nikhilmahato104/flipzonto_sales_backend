see this backend structure , now i want to make a admin panel of flipzonto  that sold the bulk product to the shop.       
 make model route view server.js   with all node,express,mongodb atlas. i have total 10 product catogary each catogary have diffrent
  schema i want to build first chocalate schema  model route  where admin can apply CRUD operation   in cholate schema in fronted pages 
   cholalate.jsx   fetch api that show all cholate products that save on db,   in schema   first image ,cholactale name,  MRP ,  total
    weight,    aviable_jar   store.      that date store on mongodb atlas .and my frontend one pages  chocolatepages.jsx  
     fetch all data that is upolated by admin in the mongodb fetch  and frontend when user order like if 10 jar is avilabe
      an user order 5 jar 5 jar will also remove from database means aviable_jar 's quintity remove ok. make accorndly like
       real life B2B project     .   admin can add as much require product they can add new product in chololate model,view,route 
       ,admin set price modify price, admin can modify quentity all thing that change in the database and also frontend fetch that data. 
       use ejs give me aslo file structure.






       const express = require('express');
const router = express.Router();
const Chocolate = require('../models/Chocolate');
const authMiddleware = require('../middleware/auth');

// 🔓 PUBLIC ROUTE: Fetch all chocolates for frontend
router.get('/api', async (req, res) => {
  try {
    const chocolates = await Chocolate.find();
    res.json(chocolates);
  } catch (err) {
    res.status(500).json({ message: 'Server error' });
  }
});

// ✅ ✅ ✅ FIXED SINGLE ROUTE FOR STOCK REDUCTION ✅ ✅ ✅
router.put('/api/order/:id', async (req, res) => {
  try {
    const { qty } = req.body;
    if (!qty || isNaN(qty) || qty <= 0) {
      return res.status(400).json({ message: 'Invalid quantity provided' });
    }

    const chocolate = await Chocolate.findById(req.params.id);
    if (!chocolate) {
      return res.status(404).json({ message: 'Chocolate not found' });
    }

    if (chocolate.available_jar < qty) {
      return res.status(400).json({ message: 'Not enough stock' });
    }

    chocolate.available_jar -= qty;
    await chocolate.save();

    res.json({ message: 'Stock updated successfully!', updated: chocolate });
  } catch (err) {
    console.error('❌ PUT error:', err.message);
    res.status(500).json({ message: 'Server error' });
  }
});

// 🔐 ADMIN ONLY: View all chocolates
router.get('/', authMiddleware, async (req, res) => {
  try {
    const chocolates = await Chocolate.find({});
    res.render('chocolate/all', { chocolates });
  } catch (err) {
    res.send('Error: ' + err.message);
  }
});

// 🔐 ADMIN ONLY: Create form
router.get('/new', authMiddleware, (req, res) => {
  res.render('chocolate/create');
});

// 🔐 ADMIN ONLY: Create chocolate
router.post('/new', authMiddleware, async (req, res) => {
  try {
    await Chocolate.create(req.body);
    res.redirect('/chocolate');
  } catch (err) {
    res.send('Error: ' + err.message);
  }
});

// 🔐 ADMIN ONLY: Edit form
router.get('/edit/:id', authMiddleware, async (req, res) => {
  try {
    const chocolate = await Chocolate.findById(req.params.id);
    res.render('chocolate/edit', { chocolate });
  } catch (err) {
    res.send('Error: ' + err.message);
  }
});

// 🔐 ADMIN ONLY: Update chocolate
router.post('/edit/:id', authMiddleware, async (req, res) => {
  try {
    await Chocolate.findByIdAndUpdate(req.params.id, req.body);
    res.redirect('/chocolate');
  } catch (err) {
    res.send('Update Error: ' + err.message);
  }
});

// 🔐 ADMIN ONLY: Delete chocolate
router.post('/delete/:id', authMiddleware, async (req, res) => {
  try {
    await Chocolate.findByIdAndDelete(req.params.id);
    res.redirect('/chocolate');
  } catch (err) {
    res.send('Delete Error: ' + err.message);
  }
});

module.exports = router;
